{"version":3,"sources":["vs/base/node/languagePacks.js"],"names":["factory","nodeRequire","path","fs","perf","exists","file","Promise","c","rimraf","location","e","lstat","err","stats","then","stat","isDirectory","isSymbolicLink","dir","readdir","files","children","all","map","child","join","rmdir","undefined","unlink","code","readFile","resolve","reject","data","writeFile","content","getNLSConfiguration","commit","userDataPath","metaDataFile","locale","availableLanguages","pseudo","process","env","initialLocale","mark","defaultResult","configs","configFile","getLanguagePackConfigurations","config","index","lastIndexOf","substring","console","error","resolveLanguagePackLocale","packConfig","mainPack","hash","translations","fileExists","packId","cacheRoot","coreLocation","translationsConfigFile","corruptedFile","result","*","_languagePackId","_translationsConfigFile","_cacheRoot","_resolvedLanguagePackCoreLocation","_corruptedFile","corrupted","toDelete","d","Date","utimes","touch","catch","mkdir","recursive","mkdirp","values","metadata","JSON","parse","packData","contents","bundles","Object","keys","writes","bundle","modules","target","create","module","defaultMessages","messages","targetStrings","i","length","elem","translatedMessage","key","push","replace","stringify","define","require","__$__nodeRequire","exports","Error"],"mappings":"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","file":"languagePacks.js","sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n//@ts-check\n\n/**\n * @param {NodeRequire} nodeRequire\n * @param {typeof import('path')} path\n * @param {typeof import('fs')} fs\n * @param {typeof import('../common/performance')} perf\n */\nfunction factory(nodeRequire, path, fs, perf) {\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<boolean>}\n\t */\n\tfunction exists(file) {\n\t\treturn new Promise(c => fs.exists(file, c));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction touch(file) {\n\t\treturn new Promise((c, e) => { const d = new Date(); fs.utimes(file, d, d, err => err ? e(err) : c()); });\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<object>}\n\t */\n\tfunction lstat(file) {\n\t\treturn new Promise((c, e) => fs.lstat(file, (err, stats) => err ? e(err) : c(stats)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string[]>}\n\t */\n\tfunction readdir(dir) {\n\t\treturn new Promise((c, e) => fs.readdir(dir, (err, files) => err ? e(err) : c(files)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<string>}\n\t */\n\tfunction mkdirp(dir) {\n\t\treturn new Promise((c, e) => fs.mkdir(dir, { recursive: true }, err => (err && err.code !== 'EEXIST') ? e(err) : c(dir)));\n\t}\n\n\t/**\n\t * @param {string} dir\n\t * @returns {Promise<void>}\n\t */\n\tfunction rmdir(dir) {\n\t\treturn new Promise((c, e) => fs.rmdir(dir, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @returns {Promise<void>}\n\t */\n\tfunction unlink(file) {\n\t\treturn new Promise((c, e) => fs.unlink(file, err => err ? e(err) : c(undefined)));\n\t}\n\n\t/**\n\t * @param {string} location\n\t * @returns {Promise<void>}\n\t */\n\tfunction rimraf(location) {\n\t\treturn lstat(location).then(stat => {\n\t\t\tif (stat.isDirectory() && !stat.isSymbolicLink()) {\n\t\t\t\treturn readdir(location)\n\t\t\t\t\t.then(children => Promise.all(children.map(child => rimraf(path.join(location, child)))))\n\t\t\t\t\t.then(() => rmdir(location));\n\t\t\t} else {\n\t\t\t\treturn unlink(location);\n\t\t\t}\n\t\t}, err => {\n\t\t\tif (err.code === 'ENOENT') {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tthrow err;\n\t\t});\n\t}\n\n\tfunction readFile(file) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.readFile(file, 'utf8', function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} file\n\t * @param {string} content\n\t * @returns {Promise<void>}\n\t */\n\tfunction writeFile(file, content) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfs.writeFile(file, content, 'utf8', function (err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\n\t/**\n\t * @param {string} userDataPath\n\t * @returns {object}\n\t */\n\tfunction getLanguagePackConfigurations(userDataPath) {\n\t\tconst configFile = path.join(userDataPath, 'languagepacks.json');\n\t\ttry {\n\t\t\treturn nodeRequire(configFile);\n\t\t} catch (err) {\n\t\t\t// Do nothing. If we can't read the file we have no\n\t\t\t// language pack config.\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {object} config\n\t * @param {string} locale\n\t */\n\tfunction resolveLanguagePackLocale(config, locale) {\n\t\ttry {\n\t\t\twhile (locale) {\n\t\t\t\tif (config[locale]) {\n\t\t\t\t\treturn locale;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = locale.lastIndexOf('-');\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\tlocale = locale.substring(0, index);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tconsole.error('Resolving language pack configuration failed.', err);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * @param {string} commit\n\t * @param {string} userDataPath\n\t * @param {string} metaDataFile\n\t * @param {string} locale\n\t */\n\tfunction getNLSConfiguration(commit, userDataPath, metaDataFile, locale) {\n\t\tif (locale === 'pseudo') {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {}, pseudo: true });\n\t\t}\n\n\t\tif (process.env['VSCODE_DEV']) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\t// We have a built version so we have extracted nls file. Try to find\n\t\t// the right file to use.\n\n\t\t// Check if we have an English or English US locale. If so fall to default since that is our\n\t\t// English translation (we don't ship *.nls.en.json files)\n\t\tif (locale && (locale === 'en' || locale === 'en-us')) {\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t}\n\n\t\tconst initialLocale = locale;\n\n\t\tperf.mark('nlsGeneration:start');\n\n\t\tconst defaultResult = function (locale) {\n\t\t\tperf.mark('nlsGeneration:end');\n\t\t\treturn Promise.resolve({ locale: locale, availableLanguages: {} });\n\t\t};\n\t\ttry {\n\t\t\tif (!commit) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst configs = getLanguagePackConfigurations(userDataPath);\n\t\t\tif (!configs) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tlocale = resolveLanguagePackLocale(configs, locale);\n\t\t\tif (!locale) {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\tconst packConfig = configs[locale];\n\t\t\tlet mainPack;\n\t\t\tif (!packConfig || typeof packConfig.hash !== 'string' || !packConfig.translations || typeof (mainPack = packConfig.translations['vscode']) !== 'string') {\n\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t}\n\t\t\treturn exists(mainPack).then(fileExists => {\n\t\t\t\tif (!fileExists) {\n\t\t\t\t\treturn defaultResult(initialLocale);\n\t\t\t\t}\n\t\t\t\tconst packId = packConfig.hash + '.' + locale;\n\t\t\t\tconst cacheRoot = path.join(userDataPath, 'clp', packId);\n\t\t\t\tconst coreLocation = path.join(cacheRoot, commit);\n\t\t\t\tconst translationsConfigFile = path.join(cacheRoot, 'tcf.json');\n\t\t\t\tconst corruptedFile = path.join(cacheRoot, 'corrupted.info');\n\t\t\t\tconst result = {\n\t\t\t\t\tlocale: initialLocale,\n\t\t\t\t\tavailableLanguages: { '*': locale },\n\t\t\t\t\t_languagePackId: packId,\n\t\t\t\t\t_translationsConfigFile: translationsConfigFile,\n\t\t\t\t\t_cacheRoot: cacheRoot,\n\t\t\t\t\t_resolvedLanguagePackCoreLocation: coreLocation,\n\t\t\t\t\t_corruptedFile: corruptedFile\n\t\t\t\t};\n\t\t\t\treturn exists(corruptedFile).then(corrupted => {\n\t\t\t\t\t// The nls cache directory is corrupted.\n\t\t\t\t\tlet toDelete;\n\t\t\t\t\tif (corrupted) {\n\t\t\t\t\t\ttoDelete = rimraf(cacheRoot);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttoDelete = Promise.resolve(undefined);\n\t\t\t\t\t}\n\t\t\t\t\treturn toDelete.then(() => {\n\t\t\t\t\t\treturn exists(coreLocation).then(fileExists => {\n\t\t\t\t\t\t\tif (fileExists) {\n\t\t\t\t\t\t\t\t// We don't wait for this. No big harm if we can't touch\n\t\t\t\t\t\t\t\ttouch(coreLocation).catch(() => { });\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn mkdirp(coreLocation).then(() => {\n\t\t\t\t\t\t\t\treturn Promise.all([readFile(metaDataFile), readFile(mainPack)]);\n\t\t\t\t\t\t\t}).then(values => {\n\t\t\t\t\t\t\t\tconst metadata = JSON.parse(values[0]);\n\t\t\t\t\t\t\t\tconst packData = JSON.parse(values[1]).contents;\n\t\t\t\t\t\t\t\tconst bundles = Object.keys(metadata.bundles);\n\t\t\t\t\t\t\t\tconst writes = [];\n\t\t\t\t\t\t\t\tfor (const bundle of bundles) {\n\t\t\t\t\t\t\t\t\tconst modules = metadata.bundles[bundle];\n\t\t\t\t\t\t\t\t\tconst target = Object.create(null);\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst keys = metadata.keys[module];\n\t\t\t\t\t\t\t\t\t\tconst defaultMessages = metadata.messages[module];\n\t\t\t\t\t\t\t\t\t\tconst translations = packData[module];\n\t\t\t\t\t\t\t\t\t\tlet targetStrings;\n\t\t\t\t\t\t\t\t\t\tif (translations) {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = [];\n\t\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst elem = keys[i];\n\t\t\t\t\t\t\t\t\t\t\t\tconst key = typeof elem === 'string' ? elem : elem.key;\n\t\t\t\t\t\t\t\t\t\t\t\tlet translatedMessage = translations[key];\n\t\t\t\t\t\t\t\t\t\t\t\tif (translatedMessage === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttranslatedMessage = defaultMessages[i];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\ttargetStrings.push(translatedMessage);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ttargetStrings = defaultMessages;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\ttarget[module] = targetStrings;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\twrites.push(writeFile(path.join(coreLocation, bundle.replace(/\\//g, '!') + '.nls.json'), JSON.stringify(target)));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrites.push(writeFile(translationsConfigFile, JSON.stringify(packConfig.translations)));\n\t\t\t\t\t\t\t\treturn Promise.all(writes);\n\t\t\t\t\t\t\t}).then(() => {\n\t\t\t\t\t\t\t\tperf.mark('nlsGeneration:end');\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}).catch(err => {\n\t\t\t\t\t\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\t\t\t\t\t\treturn defaultResult(locale);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} catch (err) {\n\t\t\tconsole.error('Generating translation files failed.', err);\n\t\t\treturn defaultResult(locale);\n\t\t}\n\t}\n\n\treturn {\n\t\tgetNLSConfiguration\n\t};\n}\n\n\nif (typeof define === 'function') {\n\t// amd\n\tdefine(['path', 'fs', 'vs/base/common/performance'], function (path, fs, perf) { return factory(require.__$__nodeRequire, path, fs, perf); });\n} else if (typeof module === 'object' && typeof module.exports === 'object') {\n\tconst path = require('path');\n\tconst fs = require('fs');\n\tconst perf = require('../common/performance');\n\tmodule.exports = factory(require, path, fs, perf);\n} else {\n\tthrow new Error('Unknown context');\n}\n"]}